
"""
	b-values

	gradient G in mT
	duration τ in ms
	k in [index]
	K0 in rad / m
	Apply function multiple times and set proper Δk 

	Definition
	k: index in phase graph, multiples of the total shift
	produced by all gradients together, unit is index.
	K: The shift in physical units (radians/m), can be non-integer
	multiples of the shift produces by all gradients together.
	sum(τ) = TR

	TODO: Split into individual gradients, because rf pulses might come inbetween!

	returns b_longitudinal, b_transverse in units of (rad/m)^2 * s
"""
function diffusion_b_values(
	G::AbstractVector{<: Real},
	τ::AbstractVector{<: Real},
	kmax::Integer
)::Tuple{Vector{Float64}, Vector{Float64}}

	@assert length(G) == length(τ)
	@assert all(τ .> 0)
	@assert kmax >= 0

	# Shift in K generated by individual gradients
	dK = γ .* G .* τ
	# Shift by all gradients together
	ΔK = sum(dK)

	# For longitudinal states, K remains constant even when gradients are non-zero.
	b_longitudinal = (0:kmax).^2 .* (ΔK^2 * sum(τ))

	# For transverse states, K changes while the gradients are non-zero.
	# Thus, individual parts of the gradient shape cannot be considered independently.
	# The previous shift K0 must be taken into account.

	# Precalculate some terms
	#=
		b_t	= b_l
			  + k * [ΔK * sum_{gradients} τ (2K0 + dK)]				# =: k * χ
			  + [sum_{gradients} τ (K0^2 + dK^2 / 3 + K0 * dK)]		# =: ξ
	=#
	local ξ, χ
	let
		K0 = Vector{Float64}(undef, length(G))
		tmp = Vector{Float64}(undef, length(G))
		# Compute K0, inital K produced by each gradient lobe
		K0[1] = 0
		K0[2:end] = cumsum(@view dK[1:end-1]) 
		# Compute elementwise ξ = sum_{gradients} τ * (K0^2 + 3 dK^2 + K0 * dK)
		@. tmp = K0^2 + dK^2 / 3 + K0 * dK
		tmp .*= τ # TODO: Needs to be split bc otherwise julia allocates memory, why?
		ξ = sum(tmp)
		# Reuse tmp to compute χ = ΔK * sum_{gradients} τ * (2K0 + dK)
		@. tmp = τ * (2K0 + dK)
		χ = ΔK * sum(tmp)
	end

	b_transverse = @. b_longitudinal + χ * (0:kmax) + ξ

	return b_longitudinal, b_transverse
end

@inline function diffusion_factor(b::Real, D::Real)
	# if b in units of (rad/m)^2 * s, then D in units of m^2/s (magnitude 1e-9)
	exp(-b * D);
end

