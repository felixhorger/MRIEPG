
"""

	Useful if the repetition time changes, but the gradients are the same.

"""
@inline function prepare_diffusion_b_values(
	G::AbstractVector{<: Real},
	τ::AbstractVector{<: Real},
	kmax::Integer
)::Tuple{Vector{Float64}, Vector{Float64}}

	@assert length(G) == length(τ)
	@assert all(t -> t > 0, τ)
	@assert kmax >= 0

	# Shift in K generated by individual gradients
	dK = γ .* G .* τ
	# Shift by all gradients together
	ΔK = sum(dK)

	# For longitudinal states, K remains constant even when gradients are non-zero.
	# Compute diffusion weighting per time (needs to be multiplied by time interval to get b-value)
	b_longitudinal_per_time = (0:kmax).^2 .* ΔK^2

	# For transverse states, K changes while the gradients are non-zero.
	# Thus, individual parts of the gradient shape cannot be considered independently.
	# The previous shift K0 must be taken into account.

	# Precalculate some terms
	#=
		b_t	= b_l
			  + k * [ΔK * sum_{gradients} τ (2K0 + dK)]			# =: k * χ
			  + [sum_{gradients} τ (K0^2 + dK^2 / 3 + K0 * dK)]		# =: ξ
	=#
	# Difference to the longitudinal b-values due to changing gradients
	local b_transverse_contribution
	let
		K0 = Vector{Float64}(undef, length(G))
		tmp = Vector{Float64}(undef, length(G))
		# Compute K0, inital K produced by each gradient lobe
		K0[1] = 0
		@views cumsum!(K0[2:end], dK[1:end-1])
		# Compute elementwise ξ = sum_{gradients} τ * (K0^2 + 3 dK^2 + K0 * dK)
		@. tmp = K0^2 + dK^2 / 3 + K0 * dK
		tmp .*= τ # Must be separate from the line above, because otherwise julia allocates memory, why?
		ξ = sum(tmp)
		# Reuse tmp to compute χ = ΔK * sum_{gradients} τ * (2K0 + dK)
		@. tmp = τ * (2K0 + dK)
		χ = ΔK * sum(tmp)
		b_transverse_contribution = χ .* (0:kmax) .+ ξ
	end

	return b_longitudinal_per_time, b_transverse_contribution
end

"""
	b-values

	gradient G in mT
	duration τ in ms
	k in [index]
	K0 in rad / m
	Apply function multiple times and set proper Δk

	Definition
	k: index in phase graph, multiples of the total shift
	produced by all gradients together, unit is index.
	K: The shift in physical units (radians/m), can be non-integer
	multiples of the shift produces by all gradients together.
	sum(τ) = TR

	TODO: Split into individual gradients, because rf pulses might come inbetween!
	Doesn't happen that often, ignore for now

	returns b_longitudinal, b_transverse in units of (rad/m)^2 * s
"""
function diffusion_b_values(
	G::AbstractVector{<: Real},
	τ::AbstractVector{<: Real},
	kmax::Integer
)::Tuple{Vector{Float64}, Vector{Float64}}
	# Note: The split between this function and prepare_diffusion_b_values is required for settings where the
	# time interval is extended in the end, without changing gradients. In that case not everything must be
	# recomputed.

	local b_longitudinal, b_transverse
	let
		b_longitudinal_per_time, b_transverse_contribution = prepare_diffusion_b_values(G, τ, kmax)
		# Use the specific duration of this time interval
		# Longitudinal
		b_longitudinal = (b_longitudinal_per_time .*= sum(τ))
		# Transverse
		b_transverse = (b_transverse_contribution .+= b_longitudinal)
	end

	return b_longitudinal, b_transverse
end

@inline function diffusion_factor(b::Real, D::Real)
	# if b in units of (rad/m)^2 * s, then D in units of m^2/s (magnitude 1e-9)
	exp(-b * D);
end

